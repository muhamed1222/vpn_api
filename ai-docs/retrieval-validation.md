# Извлечение, валидация и трансформация данных

## Обзор процесса обработки данных

Проект использует многоуровневую систему обработки данных: извлечение из источников (БД, внешние API), валидация на входе, трансформация для хранения и отправки клиентам, кэширование для оптимизации.

## Извлечение данных

### Извлечение из базы данных

Все операции с SQLite выполняются через better-sqlite3 с использованием prepared statements для защиты от SQL-инъекций.

**Примеры извлечения:**

- **getOrder(orderId: string): OrderRow | null** — извлекает заказ по ID, возвращает `null` при отсутствии
- **getOrdersByUser(userRef: string): OrderRow[]** — извлекает до 50 заказов пользователя, отсортированных по дате создания
- **getActiveKey(userRef: string): VpnKeyRow | null** — извлекает активный VPN ключ (`is_active = 1`, `revoked_at IS NULL`)

**Трансформация типов при извлечении:**
- Строковые даты (`created_at`, `updated_at`) конвертируются в `Date` объекты: `new Date(row.created_at)`
- Статусы приводятся к TypeScript типам: `row.status === 'paid' ? 'paid' : 'pending'`
- Числовые значения преобразуются: `parseInt(orderRow.user_ref?.replace('tg_', ''), 10)`
- Опциональные поля проверяются: `row.key || undefined`

### Извлечение из внешних API

**Marzban API:**
- Используется `MarzbanClient` с автоматической аутентификацией
- Поиск пользователя выполняется с двумя вариантами имени: `tg_{tgId}` и `{tgId}` (для совместимости)
- Ошибки обрабатываются: 404 возвращает `null`, 401 автоматически обновляет токен и повторяет запрос

**YooKassa API:**
- Используется `fetch` с таймаутом 30 секунд
- Ошибки парсятся как JSON или текст, специальная обработка 401 с понятными сообщениями

### Кэширование для оптимизации

VPN ключи кэшируются в таблице `vpn_keys`:
1. При первом запросе проверяется кэш (`getActiveKey`)
2. Если ключ отсутствует, запрашивается из Marzban
3. Полученный ключ сохраняется в БД для последующих запросов
4. При обновлении ключа старые помечаются неактивными (`is_active = 0`, `revoked_at = now`)

## Валидация данных

### Валидация входящих HTTP запросов

**Zod схемы для структуры данных:**

```typescript
// Схема создания заказа
const createOrderSchema = z.object({
  planId: z.string().min(1),
});

// Схема webhook от YooKassa
const yookassaWebhookSchema = z.object({
  type: z.literal('notification'),
  event: z.string(),
  object: z.object({
    id: z.string(),
    status: z.string(),
    paid: z.boolean(),
    metadata: z.object({ orderId: z.string() }).optional(),
  }),
});
```

**Использование `safeParse` для безопасной валидации:**
- Возвращает объект с полем `success` и данными или ошибками
- При неудачной валидации возвращается HTTP 400 с деталями ошибок
- Для webhook'ов невалидные данные игнорируются (возвращается 200 OK)

### Аутентификация и авторизация

**Telegram initData валидация:**
1. Парсинг querystring с сохранением оригинальных (URL-encoded) значений
2. Извлечение `hash` параметра
3. Формирование `data_check_string`: все пары кроме `hash`, отсортированные по ключу, склеенные через `\n`
4. Вычисление `secret_key = HMAC_SHA256("WebAppData", botToken)`
5. Вычисление `check_hash = HMAC_SHA256(secret_key, data_check_string)` в hex lowercase
6. Сравнение `hash` с `check_hash`
7. Проверка `auth_date` (не старше 24 часов по умолчанию)
8. Парсинг JSON из параметра `user` и проверка наличия `user.id` (number)

**JWT токен валидация:**
- Используется библиотека `jsonwebtoken` для проверки подписи и срока действия
- При истечении токена возвращается `null`
- Из payload извлекаются `tgId`, `username`, `firstName`

**Многоуровневая проверка в middleware (`verifyAuth`):**
1. Проверка Admin API Key в заголовке `x-admin-api-key`
2. Проверка JWT токена в cookie
3. Проверка Telegram initData в заголовке `Authorization`
4. Если ни один способ не сработал — возвращается 401 Unauthorized

### Валидация бизнес-правил

**Проверка доступности пробного тарифа:**
- Проверяется наличие оплаченных заказов в таблице `orders`
- Дополнительная проверка в базе бота (если доступна через ATTACH DATABASE)
- При наличии оплаченных заказов возвращается 400 с сообщением "Trial plan unavailable"

**Проверка прав доступа:**
- Проверка принадлежности заказа пользователю: `orderRow.user_ref === expectedUserRef`
- Для административных операций проверка `request.user.isAdmin === true`

**Идемпотентность операций:**
- Проверка статуса перед обновлением: если заказ уже `paid` и имеет ключ — операция пропускается
- Проверка наличия события платежа: `hasPaymentEvent` предотвращает дубли

### Валидация IP адресов

Для webhook от YooKassa (опционально):
- Проверка IP адреса отправителя через `isYooKassaIP(clientIp)`
- При невалидном IP возвращается 403 Forbidden

## Трансформация данных

### Трансформация при сохранении в БД

**Преобразование типов:**
- `Date` → ISO строка: `new Date().toISOString()`
- Числовые значения → строки для денежных сумм: `amount.value` сохраняется как `TEXT`
- Опциональные поля: `params.userRef || ''` (пустая строка вместо NULL для NOT NULL полей)

**Форматирование пользовательских ссылок:**
- `userRef` формируется как `tg_{tgId}` для всех операций
- `marzbanUsername` сохраняется для связи с Marzban

### Трансформация при возврате клиенту

**Форматирование дат:**
- Unix timestamp (секунды) → миллисекунды: `status.expire * 1000`
- ISO строка → timestamp: `new Date(order.created_at).getTime()`
- Форматирование для отображения: `new Date(Date.now() + (days * 86400 * 1000)).toLocaleDateString('ru-RU')`

**Маппинг статусов:**
- БД статусы (`'pending' | 'paid' | 'canceled'`) → клиентские статусы (`'success' | 'pending' | 'fail'`)
- Marzban статус + срок действия → boolean `isActive`: `status === 'active' && expire > now`

**Преобразование планов:**
- `planId` → читаемое название: `plan_30` → `"1 месяц"`, `plan_90` → `"3 месяца"`
- Извлечение дней из ID: `parseInt(id.replace('plan_', ''), 10)`

**Форматирование денежных сумм:**
- Строковые значения → числа: `parseFloat(order.amount_value || '0')`
- Валюта по умолчанию: `order.amount_currency || 'RUB'`

**Форматирование subscription URLs:**
- Если есть `subscription_url` в данных Marzban: `${publicUrl}${subscriptionPath}${user.subscription_url}`
- Если нет: берется первый элемент из `user.links`
- Пустой результат приводит к ошибке

### Трансформация для внешних API

**YooKassa платеж:**
- Формирование receipt для ФНС с валидным форматом (customer email, items с НДС, payment_subject, payment_mode)
- Генерация idempotence key (UUID) для предотвращения дублей
- Преобразование суммы в строку с двумя знаками после запятой

**Marzban пользователь:**
- Преобразование дней в Unix timestamp: `now + (days * 86400)`
- Формирование объекта пользователя с настройками VLESS_REALITY
- При продлении: проверка активности, если активен — добавление дней к текущему сроку, иначе установка нового срока

### Трансформация для статистики

**Расчет среднего использования трафика:**
- Использованный трафик / количество активных дней: `Math.floor(usedBytes / daysActive)`
- Проверка на деление на ноль и валидность дат

**Формирование реферальной статистики:**
- Подсчет totalCount, trialCount, premiumCount из базы бота
- Генерация referralCode: `REF{tgId}`

## Обработка ошибок

### Обработка ошибок валидации

- Zod валидация: при `success === false` возвращается 400 с массивом ошибок валидации
- Telegram initData: при невалидном hash или истекшем auth_date возвращается 401 с сообщением об ошибке
- JWT токен: при истекшем или невалидном токене возвращается 401

### Обработка ошибок извлечения

- БД: при отсутствии записи возвращается `null`, проверяется перед использованием
- Marzban API: 404 возвращает `null`, 401 автоматически обновляет токен и повторяет запрос
- YooKassa API: таймаут 30 секунд, специальная обработка 401 с понятными сообщениями об ошибках конфигурации

### Обработка ошибок трансформации

- Парсинг JSON: try-catch блоки, возврат ошибки валидации при невалидном формате
- Преобразование типов: проверка на `isNaN` для числовых значений, значения по умолчанию для опциональных полей
- Форматирование subscription URL: проверка на пустоту, логирование ошибок с деталями данных пользователя

### Идемпотентность при ошибках

- При повторной обработке webhook проверяется статус заказа и наличие ключа
- При дублях событий платежей используется UNIQUE constraint на `yookassa_event_id`, ошибка игнорируется
- Все критические операции проверяют текущее состояние перед выполнением

## Принципы безопасности

### Санитизация входных данных

- Все SQL запросы используют prepared statements с параметрами
- Telegram initData парсится с URL-декодированием, но для проверки подписи используются оригинальные значения
- Числовые значения валидируются через `parseInt` / `parseFloat` с проверкой на `isNaN`

### Защита от дублей

- Idempotence keys для YooKassa API (UUID)
- Проверка статусов перед обновлением (идемпотентные операции)
- UNIQUE constraints на `yookassa_event_id` в таблице `payment_events`

### Валидация источника данных

- Проверка IP адресов для webhook'ов (опционально)
- Криптографическая проверка подписи Telegram initData
- Проверка JWT подписи и срока действия

### Логирование для аудита

- Все операции с ключами логируются с userRef и orderId
- Ошибки валидации логируются с деталями запроса
- Webhook события логируются с полной информацией о статусе заказа
