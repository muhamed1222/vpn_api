# Архитектурные паттерны

## Обзор

Проект использует слоистую архитектуру с четким разделением ответственности между слоями. Основные паттерны применяются для управления данными, бизнес-логикой, интеграциями, обработкой HTTP-запросов и обеспечения безопасности.

## Паттерны доступа к данным

### Repository Pattern

Репозитории инкапсулируют логику работы с базой данных и предоставляют простой интерфейс для операций с данными.

**Использование:**
- Модули в `src/storage/` (ordersRepo, keysRepo, referralsRepo)
- Функции используют snake_case для имен полей БД, соответствующих структуре таблиц
- Все функции синхронные (SQLite через better-sqlite3)
- Prepared statements для защиты от SQL-инъекций

**Примеры:**
- `ordersRepo.createOrder()` — создание заказа с валидацией входных данных
- `ordersRepo.getOrder()` — получение заказа по ID, возвращает `null` при отсутствии
- `ordersRepo.markPaidWithKey()` — обновление статуса заказа и сохранение VPN ключа (идемпотентная операция)
- `keysRepo.getActiveKey()` — получение активного ключа пользователя (кэширование)
- `keysRepo.saveKey()` — сохранение ключа с автоматической деактивацией старых

**Когда использовать:**
- Для всех операций с базой данных
- Когда нужна абстракция над SQL-запросами
- Для централизации логики работы с таблицами
- Для обеспечения идемпотентности операций

### Strategy Pattern для хранилищ

Интерфейс `OrderStore` определяет контракт для работы с заказами, а конкретные реализации (`SqliteOrderStore`, `MemoryOrderStore`) предоставляют различные стратегии хранения.

**Использование:**
- `src/store/order-store.ts` — интерфейс с методами `create`, `findById`, `update`
- `src/store/sqlite-order-store.ts` — реализация для production, использует `ordersRepo`
- `src/store/memory-order-store.ts` — реализация для тестирования, использует `Map`

**Когда использовать:**
- Когда нужна возможность замены реализации хранилища
- Для тестирования без реальной базы данных
- Для абстракции источника данных от бизнес-логики
- При необходимости поддержки нескольких типов хранилищ

## Паттерны бизнес-логики

### Service Layer Pattern

Сервисы инкапсулируют бизнес-логику и координируют работу между репозиториями и внешними API.

**Использование:**
- `MarzbanService` — управление VPN пользователями, кэширование ключей
- Сервисы используют клиенты для взаимодействия с внешними API
- Сервисы работают с репозиториями для кэширования и персистентности данных

**Примеры:**
- `marzbanService.activateUser()` — активация или продление подписки, создание пользователя при необходимости
- `marzbanService.getUserConfig()` — получение конфигурации с кэшированием (сначала БД, затем Marzban)
- `marzbanService.regenerateUser()` — регенерация ключа с обновлением в БД и Marzban

**Когда использовать:**
- Для бизнес-логики, требующей координации нескольких компонентов
- Когда нужна обработка данных перед сохранением или отправкой
- Для кэширования и оптимизации запросов к внешним API
- Для инкапсуляции сложной логики работы с несколькими источниками данных

## Паттерны интеграций

### Client Pattern

Клиенты инкапсулируют взаимодействие с внешними API, управляют аутентификацией, токенами и обработкой ошибок.

**Использование:**
- `YooKassaClient` — работа с платежным API, управление idempotence keys, таймауты
- `MarzbanClient` — работа с VPN панелью, автоматическое обновление токенов при 401
- Клиенты управляют токенами и сессиями (Marzban автоматически логинится при отсутствии токена)
- Клиенты обрабатывают специфичные ошибки (404 возвращает `null`, 401 обновляет токен)

**Примеры:**
- `yookassaClient.createPayment()` — создание платежа с idempotence key и таймаутом 30 секунд
- `marzbanClient.getUser()` — получение пользователя, возвращает `null` при 404
- `marzbanClient.createUser()` — создание пользователя с настройками VLESS
- `marzbanClient.updateUser()` — обновление данных пользователя

**Когда использовать:**
- Для всех взаимодействий с внешними API
- Когда нужна централизация обработки ошибок и повторных попыток
- Для управления аутентификацией и токенами
- Для обеспечения идемпотентности запросов (idempotence keys)

## Паттерны аутентификации

### Factory Pattern для middleware

Функция `createVerifyAuth()` создает middleware для проверки авторизации с настраиваемыми параметрами.

**Использование:**
- `src/auth/verifyAuth.ts` — функция-фабрика, принимает опции (jwtSecret, cookieName, botToken, adminApiKey)
- Поддерживает три способа авторизации: Admin API Key (x-admin-api-key), JWT cookie, Telegram initData
- Возвращает функцию middleware для Fastify, которая устанавливает `request.user`

**Когда использовать:**
- Для создания конфигурируемых middleware
- Когда нужна поддержка нескольких способов аутентификации
- Для инкапсуляции логики проверки авторизации
- Для обеспечения гибкости конфигурации аутентификации

### Middleware Pattern

Middleware перехватывает запросы перед обработчиками маршрутов для проверки авторизации и установки контекста.

**Использование:**
- `preHandler: verifyAuth` в маршрутах Fastify
- Устанавливает `request.user` при успешной авторизации с полями (tgId, username, firstName, isAdmin)
- Возвращает 401 при отсутствии авторизации
- Поддерживает опциональную авторизацию для публичных маршрутов (tariffs)

**Когда использовать:**
- Для защиты маршрутов, требующих авторизации
- Для установки контекста пользователя в запросе
- Для централизованной проверки прав доступа
- Для применения единой логики аутентификации к группе маршрутов

## Паттерны маршрутизации

### Route Handler Pattern

Каждый маршрут регистрируется как отдельная функция, которая получает экземпляр Fastify и регистрирует обработчики с префиксами.

**Использование:**
- Функции с суффиксом `Routes` в `src/routes/v1/`
- Каждая функция регистрирует несколько эндпоинтов с общим префиксом
- Используется версионирование API через префиксы (`/v1/`)
- Группировка маршрутов по функциональности (auth, orders, payments, user, tariffs)

**Примеры:**
- `ordersRoutes()` — регистрирует `/v1/orders/*` (create, :orderId, history)
- `authRoutes()` — регистрирует `/v1/auth/*` (telegram, token, me)
- `paymentsRoutes()` — регистрирует `/v1/payments/*` (webhook, history)
- `userRoutes()` — регистрирует `/v1/user/*` (config, status, regenerate, renew, billing, referrals)
- `tariffsRoutes()` — регистрирует `/v1/tariffs` (список тарифов)

**Когда использовать:**
- Для организации маршрутов по функциональности
- Для группировки связанных эндпоинтов
- Для применения общих middleware к группе маршрутов
- Для версионирования API

### Plugin Registration Pattern

Маршруты регистрируются как плагины Fastify через `fastify.register()` с опциональными префиксами и опциями.

**Использование:**
- `fastify.register(routeFunction, { prefix: '/path' })` в `src/routes/index.ts`
- Rate limiting регистрируется как плагин для группы маршрутов (`/v1/*`)
- Каждый плагин изолирован и может иметь свои зависимости

**Когда использовать:**
- Для модульной организации маршрутов
- Для применения плагинов (rate limiting, CORS, cookies) к группам маршрутов
- Для обеспечения изоляции и независимости модулей

### Dependency Injection через Fastify Decorators

Сервисы и конфигурация внедряются в экземпляр Fastify через декораторы и доступны во всех маршрутах через `fastify.property`.

**Использование:**
- `fastify.decorate()` в `server.ts` для регистрации сервисов и конфигурации
- Доступ через `fastify.orderStore`, `fastify.marzbanService`, `fastify.yookassaClient` и т.д.
- Типизация через расширение модуля `fastify` (declaration merging)

**Когда использовать:**
- Для предоставления сервисов всем маршрутам без глобальных переменных
- Для централизованного управления зависимостями
- Для обеспечения типобезопасности через TypeScript
- Для упрощения тестирования (можно мокать декораторы)

## Паттерны валидации

### Schema Validation Pattern

Используется Zod для валидации входных данных в маршрутах с безопасной обработкой ошибок.

**Использование:**
- Создание схем валидации перед обработчиками (`z.object({ planId: z.string().min(1) })`)
- `safeParse()` для безопасной валидации с возвратом объекта `{ success, data, error }`
- Возврат ошибок валидации клиенту с HTTP 400 и деталями

**Примеры:**
- `createOrderSchema` — валидация создания заказа (planId обязателен)
- `yookassaWebhookSchema` — валидация webhook от YooKassa (type, event, object с метаданными)

**Когда использовать:**
- Для всех входных данных от клиента (request body, query params)
- Для проверки типов и форматов перед обработкой
- Для предотвращения некорректных данных в бизнес-логике
- Для обеспечения консистентности данных на границе системы

## Паттерны обработки ошибок

### Centralized Error Handler

Глобальный обработчик ошибок в Fastify перехватывает все исключения и форматирует единообразные ответы.

**Использование:**
- `fastify.setErrorHandler()` в `server.ts`
- Логирование ошибок через `fastify.log.error()`
- Возврат структурированных ответов с кодом статуса и сообщением об ошибке
- Graceful shutdown при получении сигналов (SIGTERM, SIGINT)

**Когда использовать:**
- Для централизованной обработки всех необработанных ошибок
- Для единообразного формата ответов об ошибках
- Для логирования исключений для мониторинга
- Для безопасного завершения работы приложения

### Idempotency Pattern

Операции с базой данных проверяют текущее состояние перед изменением, обеспечивая идемпотентность и предотвращение дублей.

**Использование:**
- `markPaidWithKey()` проверяет, не обработан ли уже заказ (если `status === 'paid'` и есть ключ — пропускает)
- `recordPaymentEvent()` игнорирует дубликаты через UNIQUE constraint на `yookassa_event_id`
- `markCanceled()` проверяет текущий статус перед обновлением

**Когда использовать:**
- Для операций, которые могут быть вызваны несколько раз (webhook события)
- Для обработки повторяющихся событий от внешних систем
- Для обеспечения консистентности данных при сбоях
- Для предотвращения дублирования побочных эффектов

## Паттерны кэширования

### Database Cache Pattern

Репозиторий ключей кэширует данные из внешнего API в локальной базе данных для быстрого доступа и снижения нагрузки на внешние системы.

**Использование:**
- `keysRepo.getActiveKey()` — проверка кэша в БД перед запросом к Marzban
- `keysRepo.saveKey()` — сохранение в кэш после получения из API с деактивацией старых ключей
- Автоматическая инвалидация старых ключей при создании новых (`is_active = 0`, `revoked_at = now`)

**Когда использовать:**
- Для данных, которые редко изменяются, но часто запрашиваются
- Для уменьшения нагрузки на внешние API
- Для улучшения производительности частых запросов
- Для обеспечения стабильности данных при временной недоступности внешних систем

## Паттерны безопасности

### Rate Limiting Pattern

Ограничение количества запросов от одного источника для защиты от перегрузки и злоупотреблений.

**Использование:**
- `@fastify/rate-limit` плагин регистрируется для всех маршрутов `/v1/*`
- Лимит: 100 запросов в минуту на IP-адрес
- Общие маршруты (root, health) не ограничены

**Когда использовать:**
- Для защиты API от перегрузки
- Для предотвращения злоупотреблений и DDoS-атак
- Для обеспечения справедливого распределения ресурсов
- Для ограничения использования внешних API

## Рекомендации по использованию

### Выбор паттерна для новой функциональности

1. **Доступ к данным** — используйте Repository Pattern в `src/storage/` для всех операций с БД
2. **Бизнес-логика** — создавайте сервисы в `src/integrations/*/service.ts` для координации компонентов
3. **Внешние API** — создавайте клиенты в `src/integrations/*/client.ts` для инкапсуляции взаимодействия
4. **HTTP маршруты** — добавляйте обработчики в соответствующие файлы `src/routes/v1/` с группировкой по функциональности
5. **Аутентификация** — используйте `createVerifyAuth()` для защищенных маршрутов
6. **Валидация** — используйте Zod схемы для всех входных данных
7. **Кэширование** — используйте Database Cache Pattern для часто запрашиваемых данных из внешних API

### Слои архитектуры

1. **Routes Layer** (`src/routes/`) — обработка HTTP запросов, валидация, вызов сервисов
2. **Service Layer** (`src/integrations/*/service.ts`) — бизнес-логика, координация компонентов, кэширование
3. **Repository Layer** (`src/storage/`) — доступ к данным, кэширование, идемпотентность
4. **Client Layer** (`src/integrations/*/client.ts`) — взаимодействие с внешними API, управление токенами
5. **Database Layer** (SQLite через better-sqlite3) — персистентное хранение данных

Каждый слой должен зависеть только от слоев ниже него, что обеспечивает модульность, тестируемость и возможность замены компонентов без изменения остальной системы.
