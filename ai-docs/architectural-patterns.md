# Архитектурные паттерны

## Обзор

Проект использует слоистую архитектуру с четким разделением ответственности между слоями. Основные паттерны применяются для управления данными, бизнес-логикой, интеграциями и обработкой HTTP-запросов.

## Паттерны доступа к данным

### Repository Pattern

Репозитории инкапсулируют логику работы с базой данных и предоставляют простой интерфейс для операций с данными.

**Использование:**
- Модули в `src/storage/` (ordersRepo, keysRepo, referralsRepo)
- Функции используют snake_case для имен полей БД
- Все функции синхронные (SQLite)

**Примеры:**
- `ordersRepo.createOrder()` - создание заказа
- `ordersRepo.getOrder()` - получение заказа по ID
- `ordersRepo.markPaidWithKey()` - обновление статуса заказа
- `keysRepo.getActiveKey()` - получение активного ключа
- `keysRepo.saveKey()` - сохранение ключа

**Когда использовать:**
- Для всех операций с базой данных
- Когда нужна абстракция над SQL-запросами
- Для централизации логики работы с таблицами

### Strategy Pattern для хранилищ

Интерфейс `OrderStore` определяет контракт для работы с заказами, а конкретные реализации (`SqliteOrderStore`, `MemoryOrderStore`) предоставляют различные стратегии хранения.

**Использование:**
- `src/store/order-store.ts` - интерфейс
- `src/store/sqlite-order-store.ts` - реализация для production
- `src/store/memory-order-store.ts` - реализация для тестирования

**Когда использовать:**
- Когда нужна возможность замены реализации хранилища
- Для тестирования без реальной базы данных
- Для абстракции источника данных от бизнес-логики

## Паттерны бизнес-логики

### Service Layer Pattern

Сервисы инкапсулируют бизнес-логику и координируют работу между репозиториями и внешними API.

**Использование:**
- `MarzbanService` - управление VPN пользователями
- Сервисы используют клиенты для внешних API
- Сервисы работают с репозиториями для кэширования данных

**Примеры:**
- `marzbanService.activateUser()` - активация/продление подписки
- `marzbanService.getUserConfig()` - получение конфигурации (с кэшированием)
- `marzbanService.regenerateUser()` - регенерация ключа

**Когда использовать:**
- Для бизнес-логики, требующей координации нескольких компонентов
- Когда нужна обработка данных перед сохранением
- Для кэширования и оптимизации запросов

## Паттерны интеграций

### Client Pattern

Клиенты инкапсулируют взаимодействие с внешними API, управляют аутентификацией и обработкой ошибок.

**Использование:**
- `YooKassaClient` - работа с платежным API
- `MarzbanClient` - работа с VPN панелью
- Клиенты управляют токенами и сессиями

**Примеры:**
- `yookassaClient.createPayment()` - создание платежа
- `marzbanClient.getUser()` - получение пользователя
- `marzbanClient.createUser()` - создание пользователя

**Когда использовать:**
- Для всех взаимодействий с внешними API
- Когда нужна централизация обработки ошибок
- Для управления аутентификацией и токенами

## Паттерны аутентификации

### Factory Pattern для middleware

Функция `createVerifyAuth()` создает middleware для проверки авторизации с настраиваемыми параметрами.

**Использование:**
- `src/auth/verifyAuth.ts`
- Поддерживает три способа авторизации: Admin API Key, JWT cookie, Telegram initData
- Возвращает функцию middleware для Fastify

**Когда использовать:**
- Для создания конфигурируемых middleware
- Когда нужна поддержка нескольких способов аутентификации
- Для инкапсуляции логики проверки авторизации

### Middleware Pattern

Middleware перехватывает запросы перед обработчиками маршрутов для проверки авторизации.

**Использование:**
- `preHandler: verifyAuth` в маршрутах
- Устанавливает `request.user` при успешной авторизации
- Возвращает 401 при отсутствии авторизации

**Когда использовать:**
- Для защиты маршрутов, требующих авторизации
- Для установки контекста пользователя в запросе
- Для централизованной проверки прав доступа

## Паттерны маршрутизации

### Route Handler Pattern

Каждый маршрут регистрируется как отдельная функция, которая получает экземпляр Fastify и регистрирует обработчики.

**Использование:**
- Функции с суффиксом `Routes` в `src/routes/`
- Каждая функция регистрирует несколько эндпоинтов
- Используется префикс для версионирования API

**Примеры:**
- `ordersRoutes()` - регистрирует `/v1/orders/*`
- `authRoutes()` - регистрирует `/v1/auth/*`
- `paymentsRoutes()` - регистрирует `/v1/payments/*`

**Когда использовать:**
- Для организации маршрутов по функциональности
- Для группировки связанных эндпоинтов
- Для применения общих middleware к группе маршрутов

### Dependency Injection через Fastify Decorators

Сервисы и конфигурация внедряются в экземпляр Fastify через декораторы и доступны во всех маршрутах.

**Использование:**
- `fastify.decorate()` в `server.ts`
- Доступ через `fastify.orderStore`, `fastify.marzbanService` и т.д.
- Типизация через расширение модуля `fastify`

**Когда использовать:**
- Для предоставления сервисов всем маршрутам
- Для избежания глобальных переменных
- Для централизованного управления зависимостями

## Паттерны валидации

### Schema Validation

Используется Zod для валидации входных данных в маршрутах.

**Использование:**
- Создание схем валидации перед обработчиками
- `safeParse()` для безопасной валидации
- Возврат ошибок валидации клиенту

**Когда использовать:**
- Для всех входных данных от клиента
- Для проверки типов и форматов
- Для предотвращения некорректных данных в бизнес-логике

## Паттерны обработки ошибок

### Centralized Error Handler

Глобальный обработчик ошибок в Fastify перехватывает все исключения и форматирует ответы.

**Использование:**
- `fastify.setErrorHandler()` в `server.ts`
- Логирование ошибок
- Возврат структурированных ответов об ошибках

**Когда использовать:**
- Для централизованной обработки всех ошибок
- Для единообразного формата ответов
- Для логирования исключений

### Idempotency Pattern

Операции с базой данных проверяют текущее состояние перед изменением, обеспечивая идемпотентность.

**Использование:**
- `markPaidWithKey()` проверяет, не обработан ли уже заказ
- `recordPaymentEvent()` игнорирует дубликаты через UNIQUE constraint
- Предотвращение повторной обработки webhook-событий

**Когда использовать:**
- Для операций, которые могут быть вызваны несколько раз
- Для обработки webhook-событий
- Для обеспечения консистентности данных

## Паттерны кэширования

### Database Cache Pattern

Репозиторий ключей кэширует данные из внешнего API в локальной базе данных для быстрого доступа.

**Использование:**
- `keysRepo.getActiveKey()` - проверка кэша перед запросом к Marzban
- `keysRepo.saveKey()` - сохранение в кэш после получения из API
- Автоматическая инвалидация старых ключей

**Когда использовать:**
- Для данных, которые редко изменяются
- Для уменьшения нагрузки на внешние API
- Для улучшения производительности частых запросов

## Рекомендации по использованию

### Выбор паттерна для новой функциональности

1. **Доступ к данным** - используйте Repository Pattern в `src/storage/`
2. **Бизнес-логика** - создавайте сервисы в `src/integrations/*/service.ts`
3. **Внешние API** - создавайте клиенты в `src/integrations/*/client.ts`
4. **HTTP маршруты** - добавляйте обработчики в соответствующие файлы `src/routes/v1/`
5. **Аутентификация** - используйте `createVerifyAuth()` для защищенных маршрутов

### Слои архитектуры

1. **Routes Layer** - обработка HTTP запросов, валидация, вызов сервисов
2. **Service Layer** - бизнес-логика, координация компонентов
3. **Repository Layer** - доступ к данным, кэширование
4. **Client Layer** - взаимодействие с внешними API
5. **Database Layer** - SQLite база данных

Каждый слой должен зависеть только от слоев ниже него, что обеспечивает модульность и тестируемость кода.
